#!/bin/tcsh

# AP SIMPLE: run afni_proc.py for full FMRI processing (quick/simple proc)
#  -> the Desktop version

# This script runs a corresponding do_*.tcsh script for a given
# subj+ses pair. This script loops over subj+ses pairs from basic dir

# To execute:  
#     tcsh RUN_SCRIPT_NAME

# --------------------------------------------------------------------------

set dir_input  = ""            # dir name: contains all raw data sub dirs
set dir_output = ""            # dir name: to be output of all deriv dirs

set all_subj   = ( )           # list of all subj IDs; def: proc all subj

set OK_SUBJ_FAIL = 0           # by default, stop at first failed subj proc

set bindir = `dirname "$0"`

# ------------------- process options, a la rr ----------------------

if ( $#argv == 0 ) goto SHOW_HELP

set ac = 1
while ( $ac <= $#argv )
    # terminal options
    if ( ("$argv[$ac]" == "-h" ) || ("$argv[$ac]" == "-help" )) then
        goto SHOW_HELP
    endif
    if ( "$argv[$ac]" == "-ver" ) then
        goto SHOW_VERSION
    endif

    if ( "$argv[$ac]" == '-echo' ) then
        set echo

    # --------- required

    else if ( "$argv[$ac]" == "-dir_input" ) then
        if ( $ac >= $#argv ) goto FAIL_MISSING_ARG
        @ ac += 1
        set dir_input = "$argv[$ac]"

    else if ( "$argv[$ac]" == "-dir_output" ) then
        if ( $ac >= $#argv ) goto FAIL_MISSING_ARG
        @ ac += 1
        set dir_output = "$argv[$ac]"

    # --------- opt

    else if ( "$argv[$ac]" == "-participant_list" ) then
        if ( $ac >= $#argv ) goto FAIL_MISSING_ARG
        @ ac += 1
        # keep adding to list until another option or end of inputs
        while ( $ac <= $narg )
            if ( "`echo $argv[$ac] | cut -b 1`" == "-" ) break
            set all_subj = ( ${all_subj} $argv[$ac] )
            @ ac ++
        end
        # now at arg not belonging to this opt
        @ ac -= 1

    else if ( "$argv[$ac]" == "-ok_subj_fail" ) then
        set OK_SUBJ_FAIL = 1

    else
        echo "\n\n** ERROR: unexpected option #$ac = '$argv[$ac]'\n\n"
        goto BAD_EXIT
        
    endif
    @ ac += 1
end

# =======================================================================
# ======================== ** Verify + setup ** =========================
# =======================================================================

# check if input dir provided, and its existence
if ( "${dir_input}" == "" ) then
    echo "** ERROR: need to provide input dir name with '-dir_input ..'"
    goto BAD_EXIT
else if ( ! -d "${dir_input}" ) then
    echo "** ERROR: invalid input dir via '-dir_input ..'"
    goto BAD_EXIT
endif

# check if output dir provided, and if it will be/can be overwritten
if ( "${dir_output}" == "" ) then
    echo "** ERROR: need to provide output dir name with '-dir_output ..'"
    goto BAD_EXIT
endif

# get/check all subj dirs 
if ( ! ${#all_subj} ) then
    # user didn't provide list, get our own
    cd ${dir_input}
    set all_subj = ( sub-* )
    cd -

    # must have at least one
    if ( ! ${#all_subj} ) then
        echo "** ERROR: cannot find any subj in input dir: ${dir_input}"
        goto BAD_EXIT
    endif
else
    # verify all user-entered subj IDs
    cd ${dir_input}
    foreach subj ( ${all_subj} )
        set ok = `python -c "import glob; print(len(glob.glob('${subj}')))"`
        if ( ! ${ok} ) then
            echo "** ERROR: cannot find user-entered subj dir: ${subj}"
            goto BAD_EXIT
        endif
    end
endif

# =======================================================================

# specify script to execute
set cmd           = 20_ap_simple

# basic and output need to be abs path
cd ${dir_input}
set dir_input = ${PWD}
cd -
\mkdir -p ${dir_output}
cd ${dir_output}
set dir_output = ${PWD}
cd -

# upper directories
set dir_scr       = $bindir
set dir_swarm     = ${dir_output}/code

# running
set scr_swarm     = ${dir_swarm}/swarm_${cmd}
set scr_cmd       = ${dir_scr}/do_${cmd}

# --------------------------------------------------------------------------
# swarm script stuff

# make output directory and swarm directory, if not already existing
\mkdir -p ${dir_swarm}

# clear away older swarm script 
if ( -e ${scr_swarm} ) then
    \rm ${scr_swarm}
endif

echo '#\!/bin/sh' > ${scr_swarm}
# do we exit when one subj proj fails?
if ( ! ${OK_SUBJ_FAIL} ) then
    echo 'set -e' >> ${scr_swarm}
endif
chmod a+x ${scr_swarm}

# --------------------------------------------------------------------------

cat <<EOF

++ Proc command:  ${cmd}
++ Have ${#all_subj} subj

EOF

# -------------------------------------------------------------------------
# build swarm command

# loop over all subj
foreach subj ( ${all_subj} )

    # use python to check if we have session level
    cd ${dir_input}/${subj}
    set all_ses = `python -c "import glob; print(' '.join(glob.glob('ses-*')))"`
    set nses    = ${#all_ses}
    cd -

    if ( ${nses} ) then
        # loop over all ses
        foreach ses ( ${all_ses} )
            echo "++ Prepare cmd for: ${subj} - ${ses}"

            # add cmd to swarm script (verbosely, and don't use '-e')
            echo "tcsh -xf ${scr_cmd} ${dir_input} ${dir_output} ${subj} ${ses}"    >> ${scr_swarm}
        end
    else
        echo "++ Prepare cmd for: ${subj}"

        # add cmd to swarm script (verbosely, and don't use '-e')
        echo "tcsh -xf ${scr_cmd} ${dir_input} ${dir_output} ${subj} "    >> ${scr_swarm}
    endif
end

# -------------------------------------------------------------------------
# run swarm command
cd ${dir_scr}

echo "++ And start running: ${scr_swarm}"

##exit 0

# execute the script, which contains all subj to proc
${scr_swarm}

# nous sommes finis
if ( $status ) then
    goto BAD_EXIT
else
    goto GOOD_EXIT
endif

# ========================================================================
# ========================================================================

SHOW_HELP:
cat << EOF
-------------------------------------------------------------------------

Overview ~1~

This is a script to process a data collection that is in BIDS format
with a simple form of afni_proc.py. 

ver  = ${version}
auth = PA Taylor (SSCC, NIMH, NIH)
-------------------------------------------------------------------------

Options ~1~

-dir_input   DI  :(req) input/top dir of BIDS-format data collection

-dir_output  DO  :(req) output dirname for afni_proc.py BIDS-derivatives

-participant_list  SUBJ1 [SUBJ2 SUBJ3 ...]
                 : user can input one or more subject IDs to process
                   (def: process all 'sub-*' dirs in dir_input)

-ok_subj_fail    : keep processing subjects, even if one fails (def: stop 
                   processing at first subject failure)

-echo            : run very verbosely (with 'set echo' on)

-ver             : display program version

-help            : show help

-hview           : show help in text editor

-------------------------------------------------------------------------

Examples ~1~

1) Basic usage:

   ****

EOF

# ----------------------------------------------------------------------

    goto GOOD_EXIT

SHOW_VERSION:
   echo "version  $version (${rev_dat})"
   goto GOOD_EXIT

FAIL_MISSING_ARG:
    echo "** ERROR: Missing an argument after option flag: '$argv[$ac]'"
    goto BAD_EXIT

BAD_EXIT:
    exit 1

GOOD_EXIT:
    exit 0
